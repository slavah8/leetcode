class DSU:
    def __init__(self, N):
        self.parent = [i for i in range(N)]
        self.rank = [0] * N
    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        
        return x
    
    def union(self, a, b):
        root1, root2 = self.find(a), self.find(b)

        if root1 == root2:
            return

        if self.rank[root1] < self.rank[root2]:
            root1, root2 = root2, root1
        
        self.parent[root2] = root1
        if self.rank[root1] == self.rank[root2]:
            self.rank[root1] += 1
        

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        N = len(graph) # number of computers
        dsu = DSU(N)
        for i in range(N):
            row = graph[i]
            for j in range(i + 1, N):
                if row[j] == 1:
                    dsu.union(i, j)
        
        component_size = {}
        for i in range(N):
            root = dsu.find(i)
            component_size[root] = component_size.get(root, 0) + 1
        print(component_size)

        infected_count = {}
        for u in initial:
            root = dsu.find(u)
            infected_count[root] = infected_count.get(root, 0) + 1
        
        print(infected_count)

        best_save = -1
        answer = min(initial)
        for u in sorted(initial):
            root = dsu.find(u)
            if infected_count.get(root, 0) == 1:
                saved = component_size[root]
                if saved > best_save:
                    best_save = saved
                    answer = u

                    
        return answer